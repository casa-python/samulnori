import React, { useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';
import useSoundMapping from '../../hooks/useSoundMapping';
import '../../styles/common/SoundMappingModal.css';

function SoundMappingModal({ open, onClose, object, onSave, initialMapping, treeData }) {
  const {
    gloves,
    dragOverTarget,
    mappingStatus,
    fingerPositions,
    setDragOverTarget,
    setDraggedSound,
    handleDragStart,
    handleDragOver,
    handleDragLeave,
    handleDrop,
    handleHandDrop,
    handleSave,
    resetLocalMapping
  } = useSoundMapping({ open, object, onSave });

  // Î™®Îã¨ ÏßÄÏó≠ ÏÉÅÌÉúÎäî ÌõÖ ÏàúÏÑúÎ•º ÏßÄÌÇ§Í∏∞ ÏúÑÌï¥ Ï°∞Í∏∞ Î¶¨ÌÑ¥ Ï†ÑÏóê ÏÑ†Ïñ∏ÌïúÎã§
  const [localTree, setLocalTree] = useState([]);
  const [fileVolumeMap, setFileVolumeMap] = useState({});
  // Ìè¥Îçî Ï†ëÌûò ÏÉÅÌÉú Í¥ÄÎ¶¨: ÏßëÌï©Ïóê Ìè¨Ìï®ÎêòÎ©¥ Ï†ëÌûò(collapsed)
  const [collapsedFolders, setCollapsedFolders] = useState(new Set());
  // ÎØ∏Î¶¨Îì£Í∏∞ Ïû¨ÏÉù ÏÉÅÌÉú Í¥ÄÎ¶¨
  const [previewPlayingId, setPreviewPlayingId] = useState(null);
  const currentPreviewIdRef = useRef(null);
  const webAudioSourceRef = useRef(null);

  const isFolderExpanded = (key) => !collapsedFolders.has(key);
  const toggleFolder = (key) => {
    setCollapsedFolders((prev) => {
      const next = new Set(prev);
      if (next.has(key)) {
        next.delete(key);
      } else {
        next.add(key);
      }
      return next;
    });
  };

  // Ìä∏Î¶¨ÏóêÏÑú Ìè¥Îçî ÌÇ§ ÏàòÏßë
  const collectFolderKeys = (nodes, parentPath = '', acc = new Set()) => {
    if (!Array.isArray(nodes)) return acc;
    nodes.forEach((node) => {
      const nodeKey = parentPath ? `${parentPath}/${node.name}` : node.name;
      if (node?.type === 'folder') {
        acc.add(nodeKey);
        if (Array.isArray(node.children) && node.children.length > 0) {
          collectFolderKeys(node.children, nodeKey, acc);
        }
      }
    });
    return acc;
  };

  // Î™®Îã¨Ïù¥ Ïó¥Î¶¥ Îïå Í∏∞Î≥∏ samples Ìè¥Îçî Î°úÎìú
  useEffect(() => {
    if (open && (!treeData || treeData.length === 0) && (!localTree || localTree.length === 0)) {
      const loadDefaultSamples = async () => {
        try {
          if (window.electronAPI?.loadDefaultSamples) {
            // samples Ìè¥ÎçîÎ•º Í∏∞Î≥∏Í∞íÏúºÎ°ú Î°úÎìú
            const result = await window.electronAPI.loadDefaultSamples();
            if (result && Array.isArray(result.tree)) {
              setLocalTree(result.tree);
            }
          }
        } catch (error) {
          console.log('Í∏∞Î≥∏ samples Ìè¥Îçî Î°úÎìú Ïã§Ìå®:', error);
        }
      };
      loadDefaultSamples();
    }
  }, [open, treeData, localTree]);

  // Ï¥àÍ∏∞ÏóêÎäî Î™®Îì† Ìè¥ÎçîÎ•º Ï†ëÏùÄ ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
  useEffect(() => {
    const activeTree = (localTree && localTree.length > 0) ? localTree : treeData;
    if (!activeTree || activeTree.length === 0) return;
    const allFolderKeys = collectFolderKeys(activeTree);
    setCollapsedFolders(allFolderKeys);
  }, [localTree, treeData]);

  // Ïò§ÎîîÏò§ Ïû¨ÏÉùÍ∏∞: Îã®Ïùº Ïù∏Ïä§ÌÑ¥Ïä§ Ïú†ÏßÄ
  const audioRef = useRef(null);
  const audioCtxRef = useRef(null);
  useEffect(() => {
    audioRef.current = new Audio();
    audioRef.current.preload = 'auto';
    const AC = window.AudioContext || window.webkitAudioContext;
    if (AC) {
      try { audioCtxRef.current = new AC(); } catch {}
    }
    // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎ°ú Ïû¨ÏÉù Ï¢ÖÎ£å Ïãú UI ÏÉÅÌÉú Î≥µÏõê
    const player = audioRef.current;
    const handleEnded = () => {
      setPreviewPlayingId(null);
      currentPreviewIdRef.current = null;
    };
    player.addEventListener('ended', handleEnded);
    return () => {
      try {
        audioRef.current?.pause();
        audioRef.current && (audioRef.current.src = '');
        if (audioCtxRef.current) {
          try { audioCtxRef.current.close(); } catch {}
          audioCtxRef.current = null;
        }
        try { player.removeEventListener('ended', handleEnded); } catch {}
        try {
          webAudioSourceRef.current?.stop(0);
          webAudioSourceRef.current?.disconnect();
        } catch {}
        webAudioSourceRef.current = null;
        currentPreviewIdRef.current = null;
      } catch {}
    };
  }, []);

  // Ïó¥Î¶º/Îã´Ìûò Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏúÑÌïú ÎßàÏö¥Ìä∏ Ïú†ÏßÄ
  const [shouldRender, setShouldRender] = useState(open);
  const [isClosing, setIsClosing] = useState(false);

  useEffect(() => {
    if (open) {
      setShouldRender(true);
      setIsClosing(false);
      return;
    }
    // Îã´Ìûê ÎïåÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ Ïñ∏ÎßàÏö¥Ìä∏
    if (shouldRender) {
      setIsClosing(true);
      const timeout = setTimeout(() => {
        setIsClosing(false);
        setShouldRender(false);
      }, 230); // CSS Ïï†ÎãàÎ©îÏù¥ÏÖòÍ≥º ÎèôÍ∏∞Ìôî
      return () => clearTimeout(timeout);
    }
  }, [open, shouldRender]);

  if (!shouldRender || !object) return null;

  const fingerNames = {
    '0': 'ÏóÑÏßÄ',
    '1': 'Í≤ÄÏßÄ',
    '2': 'Ï§ëÏßÄ',
    '3': 'ÏïΩÏßÄ',
    '4': 'ÏÉàÎÅº',
    '5': 'ÏÜêÎ∞îÎã•',
    '6': 'ÏÜêÎÇ†'
  };

  const handleCloseButtonClick = () => onClose();
  const handleOverlayClick = (e) => { if (e.target === e.currentTarget) onClose(); };
  const handleSaveClick = async () => {
    await handleSave();
    if (typeof onClose === 'function') onClose();
  };

  // ÎØ∏Î¶¨Îì£Í∏∞ Ï†ïÏßÄ
  const stopPreview = () => {
    try { audioRef.current?.pause(); } catch {}
    try {
      if (webAudioSourceRef.current) {
        webAudioSourceRef.current.stop(0);
        webAudioSourceRef.current.disconnect();
      }
    } catch {}
    webAudioSourceRef.current = null;
    currentPreviewIdRef.current = null;
    setPreviewPlayingId(null);
  };

  // ÏÇ¨Ïö¥Îìú ÎØ∏Î¶¨Îì£Í∏∞ (Î©îÏù∏ÏóêÏÑú ÏùΩÏñ¥Ïò® data URL ÏÇ¨Ïö©)
  const playPreview = async (soundPath, volume) => {
    try {
      if (!window.electronAPI?.readAudioAsDataUrl) {
        return;
      }
      // Í∞ôÏùÄ Ìï≠Î™© Ïû¨ÌÅ¥Î¶≠ Ïãú ÌÜ†Í∏Ä Ï†ïÏßÄ
      if (previewPlayingId === soundPath) {
        stopPreview();
        return;
      }
      const dataUrl = await window.electronAPI.readAudioAsDataUrl(soundPath);
      if (!dataUrl || !audioRef.current) {
        return;
      }
      // Ïù¥Ï†Ñ Ïû¨ÏÉù Ï§ëÎã® ÌõÑ ÏÑ§Ï†ï
      stopPreview();
      const player = audioRef.current;
      player.currentTime = 0;
      player.src = dataUrl;
      player.volume = Math.min(Math.max(volume ?? 1, 0), 1);
      currentPreviewIdRef.current = soundPath;
      setPreviewPlayingId(soundPath);
      await player.play().catch(async (e) => {
        // Fallback: WebAudioÎ°ú Ïû¨ÏÉù ÏãúÎèÑ
        if (!audioCtxRef.current) return;
        const res = await fetch(dataUrl);
        const buf = await res.arrayBuffer();
        const ctx = audioCtxRef.current;
        try {
          const decoded = await ctx.decodeAudioData(buf.slice(0));
          const source = ctx.createBufferSource();
          const gain = ctx.createGain();
          gain.gain.value = Math.min(Math.max(volume ?? 1, 0), 1);
          source.buffer = decoded;
          source.connect(gain).connect(ctx.destination);
          try {
            webAudioSourceRef.current?.stop(0);
            webAudioSourceRef.current?.disconnect();
          } catch {}
          webAudioSourceRef.current = source;
          currentPreviewIdRef.current = soundPath;
          setPreviewPlayingId(soundPath);
          source.onended = () => {
            if (currentPreviewIdRef.current === soundPath) {
              setPreviewPlayingId(null);
              currentPreviewIdRef.current = null;
            }
            try { source.disconnect(); } catch {}
            if (webAudioSourceRef.current === source) {
              webAudioSourceRef.current = null;
            }
          };
          source.start(0);
        } catch (e) {
          console.error('Ïò§ÎîîÏò§ Ïû¨ÏÉù Ïã§Ìå®:', e);
        }
      });
    } catch (e) {
      console.error('ÎØ∏Î¶¨Îì£Í∏∞ Ïã§Ìå®:', e);
    }
  };

  // ÏÇ¨Ïö¥Îìú Ìä∏Î¶¨ Î†åÎçîÎßÅ Ìï®Ïàò
  const renderSoundTree = (nodes, level = 0, parentPath = '') => {
    return nodes.map((node, index) => {
      const nodeKey = parentPath ? `${parentPath}/${node.name}` : node.name;
      const expanded = node.type === 'folder' ? isFolderExpanded(nodeKey) : true;
      return (
        <div key={`${nodeKey}-${index}`}>
          <div
            className={`sound-tree-item ${node.type}`}
            style={{ paddingLeft: `${level * 16}px` }}
            draggable={node.type === 'file'}
            onClick={(e) => { if (node.type === 'folder') { e.stopPropagation(); toggleFolder(nodeKey); } }}
            onDragStart={(e) => handleDragStart(e, node.name, node.id, fileVolumeMap[node.id] ?? 1)}
            onDragEnd={(e) => { e.preventDefault(); }}
            aria-expanded={node.type === 'folder' ? expanded : undefined}
          >
            <span className="sound-tree-icon">{node.type === 'folder' ? 'üìÅ' : 'üéµ'}</span>
            <div className="sound-tree-row-grid">
              <span className="sound-tree-name">
                {node.type === 'folder' && (
                  <span className="sound-tree-toggle">{expanded ? '‚ñæ' : '‚ñ∏'}</span>
                )}
                {node.name}
              </span>
              {node.type === 'file' && node.id && (
                <>
                  <button
                    type="button"
                    className={`sound-tree-play ${previewPlayingId === node.id ? 'playing' : ''}`}
                    onClick={(e) => { e.stopPropagation(); playPreview(node.id, fileVolumeMap[node.id] ?? 1); }}
                    title={previewPlayingId === node.id ? 'Ï†ïÏßÄ' : 'ÎØ∏Î¶¨Îì£Í∏∞'}
                  >{previewPlayingId === node.id ? '‚è∏' : '‚ñ∂'}</button>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.01"
                    value={fileVolumeMap[node.id] ?? 1}
                    onClick={(e) => e.stopPropagation()}
                    onChange={(e) => setFileVolumeMap((prev) => ({ ...prev, [node.id]: Number(e.target.value) }))}
                    className="sound-tree-volume"
                    title="Î≥ºÎ•®"
                  />
                </>
              )}
            </div>
          </div>
          {node.children && node.children.length > 0 && expanded && (
            <div>{renderSoundTree(node.children, level + 1, nodeKey)}</div>
          )}
        </div>
      );
    });
  };

  const modalContent = (
    <div className={`sound-mapping-modal-overlay${isClosing ? ' closing' : ''}`} onClick={handleOverlayClick}>
      <div className={`sound-mapping-modal-content${isClosing ? ' closing' : ''}`}>
        {/* Ìó§Îçî (Ïä§Ìã∞ÌÇ§) */}
        <div className="sound-mapping-header">
          <div className="sound-mapping-header-content">
            <div className="sound-mapping-title">
              <div className="sound-mapping-title-content">
                <h2>üéµ Í∏ÄÎü¨Î∏å ÏÇ¨Ïö¥Îìú Îß§Ìïë</h2>
                <p>{object.class_name}_{object.trackId}</p>
              </div>
              <p>ÏÉòÌîåÏùÑ Í∏ÄÎü¨Î∏å Îß§ÌïëÏóê ÎìúÎûòÍ∑∏ÌïòÏÑ∏Ïöî.</p>
            </div>
            
            {/* Ìë∏ÌÑ∞ (Ïä§Ìã∞ÌÇ§) */}
            <div className="sound-mapping-footer">
              <button className="sound-mapping-save-button" onClick={handleSaveClick}>Ï†ÄÏû•</button>
            </div>
          </div>
          <button className="sound-mapping-close-button" onClick={handleCloseButtonClick} aria-label="Îã´Í∏∞">√ó</button>
        </div>

        {/* Î©îÏù∏ Ïª®ÌÖêÏ∏† (Ï¢å: ÏÉÅÌÉú/ÏÇ¨Ïö¥Îìú Î™©Î°ù, Ïö∞: ÏÜê Îß§Ìïë) */}
        <div className="sound-mapping-main-content">
          {/* ÏôºÏ™Ω: ÏÉÅÌÉú + ÏÇ¨Ïö¥Îìú Î™©Î°ù */}
          <div className="sound-mapping-left">
            {/* ÏÉÅÌÉú Î∞î (Ïª¥Ìå©Ìä∏) */}
            <div className="sound-mapping-status">
              <div className="sound-mapping-status-title"><span>üìã</span>ÌòÑÏû¨ Îß§Ìïë ÏÉÅÌÉú</div>
              <div className="sound-mapping-status-content" title={mappingStatus}>
                <div className="sound-mapping-status-grid">
                  <div className="status-col">
                    <div className="status-col-header">üñêÔ∏è LEFT</div>
                    <div className="status-col-rows">
                      {fingerPositions.left.map((pos) => (
                        <div className="status-row" key={`status-left-${pos.id}`}>
                          <span className="status-row-label">L-{pos.id} ({fingerNames[pos.id]})</span>
                          <span className="status-row-sep">|</span>
                          <span className={`status-row-value ${gloves.left[pos.id] ? 'mapped' : 'unmapped'}`}>
                            {gloves.left[pos.id]?.name || 'ÎØ∏ÏÑ§Ï†ï'}
                          </span>
                        </div>
                      ))}
                    </div>
                  </div>
                  <div className="status-col">
                    <div className="status-col-header">üñêÔ∏è RIGHT</div>
                    <div className="status-col-rows">
                      {fingerPositions.right.map((pos) => (
                        <div className="status-row" key={`status-right-${pos.id}`}>
                          <span className="status-row-label">R-{pos.id} ({fingerNames[pos.id]})</span>
                          <span className="status-row-sep">|</span>
                          <span className={`status-row-value ${gloves.right[pos.id] ? 'mapped' : 'unmapped'}`}>
                            {gloves.right[pos.id]?.name || 'ÎØ∏ÏÑ§Ï†ï'}
                          </span>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            </div>

            {/* ÏÇ¨Ïö¥Îìú Î™©Î°ù */}
            <div className="sound-mapping-sound-list">
            <div className="sound-mapping-sound-list-title" style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
              <span>üìã ÏÇ¨Ïö¥Îìú Î™©Î°ù</span>
              <button
                type="button"
                className="sound-mapping-folder-button"
                onClick={async () => {
                  try {
                    const result = await window.electronAPI?.selectSampleFolder?.();
                    if (result && Array.isArray(result.tree)) {
                      // SoundMappingModalÏùÄ Î∞õÏùÄ treeDataÎ•º Í∑∏ÎåÄÎ°ú Ïì∞ÎØÄÎ°ú, ÏÉÅÏúÑ Ïª¥Ìè¨ÎÑåÌä∏Ïùò ÏÉÅÌÉúÎ•º Î∞îÍæ∏ÏßÄ ÏïäÍ≥† ÎÇ¥Î∂Ä ÏßÄÏó≠ ÏÉÅÌÉúÎ°ú ÌëúÏãú
                      // Í∞ÑÌé∏ÌïòÍ≤å ÌòÑÏû¨ Ïª¥Ìè¨ÎÑåÌä∏ Î†àÎ≤®ÏóêÏÑú ÏûÑÏãúÎ°ú treeDataÎ•º ÎåÄÏ≤¥ ÌëúÏãúÌïòÍ∏∞ ÏúÑÌï¥ setLocalTree ÏÇ¨Ïö©
                      setLocalTree(result.tree);
                    }
                  } catch {}
                }}
              >ÏÉòÌîå Ìè¥Îçî ÏÑ†ÌÉù</button>
            </div>
            <div className="sound-mapping-sound-list-container">
              {(localTree && localTree.length > 0) || (treeData && treeData.length > 0) ? (
                <div className="sound-mapping-sound-list-content">{renderSoundTree(localTree && localTree.length > 0 ? localTree : treeData)}</div>
                             ) : (
                 <div className="sound-mapping-sound-list-loading">ÏõêÌïòÏãúÎäî ÏÇ¨Ïö¥Îìú ÏÉòÌîå Í≤ΩÎ°úÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.</div>
               )}
            </div>
            </div>

            {/* ÏôºÏ™Ω Ïª¨Îüº Ï¢ÖÎ£å */}
          </div>

          {/* Ïò§Î•∏Ï™Ω: ÏÜê Îß§Ìïë */}
          <div className="sound-mapping-hands-container">
            <div className="sound-mapping-hands-title-container">
              <div className="sound-mapping-hands-title">Í∏ÄÎü¨Î∏å Îß§Ìïë</div>
              
              {/* Î°úÏª¨ Ï¥àÍ∏∞Ìôî Î≤ÑÌäº */}
              <button
                  type="button"
                  className="sound-mapping-reset-button"
                  onClick={resetLocalMapping}
                  title="Î™®Îã¨ ÎÇ¥ Îß§Ìïë Ï¥àÍ∏∞Ìôî (Ïä§ÌÜ†Ïñ¥ÏóêÎäî ÏòÅÌñ• ÏóÜÏùå)"
                >Îß§Ìïë Ï¥àÍ∏∞Ìôî</button>
            </div>
            
            <div className="sound-mapping-hands-image-container">
              {/* ÏôºÏÜê Îß§Ìïë Ìè¨Ïù∏Ìä∏Îì§ */}
              {fingerPositions.left.map((pos) => (
                <div
                  key={`left-${pos.id}`}
                  className={`sound-mapping-finger-point ${gloves.left[pos.id] ? 'mapped' : 'unmapped'} ${dragOverTarget === `left-${pos.id}` ? 'drag-over' : ''}`}
                  style={{ left: `${pos.x}%`, top: `${pos.y}%` }}
                  onDragOver={(e) => handleDragOver(e, `left-${pos.id}`)}
                  onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); setDragOverTarget(`left-${pos.id}`); }}
                  onDragLeave={(e) => handleDragLeave(e)}
                  onDrop={(e) => handleDrop(e, 'left', pos.id)}
                  title={`ÏôºÏÜê ${pos.id}Î≤à: ${gloves.left[pos.id] ? `${gloves.left[pos.id].name} (ID: ${gloves.left[pos.id].id})` : 'ÎØ∏ÏÑ§Ï†ï'}`}
                >L-{pos.id}</div>
              ))}

              {/* Ïò§Î•∏ÏÜê Îß§Ìïë Ìè¨Ïù∏Ìä∏Îì§ */}
              {fingerPositions.right.map((pos) => (
                <div
                  key={`right-${pos.id}`}
                  className={`sound-mapping-finger-point ${gloves.right[pos.id] ? 'mapped' : 'unmapped'} ${dragOverTarget === `right-${pos.id}` ? 'drag-over' : ''}`}
                  style={{ left: `${pos.x}%`, top: `${pos.y}%` }}
                  onDragOver={(e) => handleDragOver(e, `right-${pos.id}`)}
                  onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); setDragOverTarget(`right-${pos.id}`); }}
                  onDragLeave={(e) => handleDragLeave(e)}
                  onDrop={(e) => handleDrop(e, 'right', pos.id)}
                  title={`Ïò§Î•∏ÏÜê ${pos.id}Î≤à: ${gloves.right[pos.id] ? `${gloves.right[pos.id].name} (ID: ${gloves.right[pos.id].id})` : 'ÎØ∏ÏÑ§Ï†ï'}`}
                >R-{pos.id}</div>
              ))}

              {/* ÏôºÏÜê Ï†ÑÏ≤¥ ÎìúÎ°≠ ÏòÅÏó≠ */}
              <div
                className={`sound-mapping-hand-drop-area left ${dragOverTarget === 'left-hand' ? 'drag-over' : ''}`}
                onDragOver={(e) => handleDragOver(e, 'left-hand')}
                onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); setDragOverTarget('left-hand'); }}
                onDragLeave={(e) => handleDragLeave(e)}
                onDrop={(e) => handleHandDrop(e, 'left')}
                title="ÏôºÏÜê Ï†ÑÏ≤¥Ïóê Îß§Ìïë"
              >LEFT</div>

              {/* Ïò§Î•∏ÏÜê Ï†ÑÏ≤¥ ÎìúÎ°≠ ÏòÅÏó≠ */}
              <div
                className={`sound-mapping-hand-drop-area right ${dragOverTarget === 'right-hand' ? 'drag-over' : ''}`}
                onDragOver={(e) => handleDragOver(e, 'right-hand')}
                onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); setDragOverTarget('right-hand'); }}
                onDragLeave={(e) => handleDragLeave(e)}
                onDrop={(e) => handleHandDrop(e, 'right')}
                title="Ïò§Î•∏ÏÜê Ï†ÑÏ≤¥Ïóê Îß§Ìïë"
              >RIGHT</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );

  return ReactDOM.createPortal(modalContent, document.body);
}

export default SoundMappingModal;